(window.webpackJsonp=window.webpackJsonp||[]).push([[4],{371:function(t,_,a){t.exports=a.p+"assets/img/tcp-header.f0317cf2.jpg"},372:function(t,_,a){t.exports=a.p+"assets/img/tcp-state-machine.43a09603.jpg"},373:function(t,_,a){t.exports=a.p+"assets/img/tcp-state-transition.803bd599.jpg"},374:function(t,_,a){t.exports=a.p+"assets/img/tcp-shake-hands.171d8920.jpg"},375:function(t,_,a){t.exports=a.p+"assets/img/tcp-wave.43ee4064.jpg"},399:function(t,_,a){"use strict";a.r(_);var v=a(45),s=Object(v.a)({},(function(){var t=this,_=t.$createElement,v=t._self._c||_;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h1",{attrs:{id:"tcp"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#tcp"}},[t._v("#")]),t._v(" TCP")]),t._v(" "),v("p",[t._v("Transmission Control Protocol，传输控制协议。属于传输层通信协议，基于TCP的应用层协议有: HTTP(s)，SMTP，FTP，Telnet 和 POP3")]),t._v(" "),v("p",[v("strong",[t._v("优点")]),t._v(": 提供可靠传输，具有拥塞控制")]),t._v(" "),v("p",[v("strong",[t._v("缺点")]),t._v(": 传输效率低，慢启动")]),t._v(" "),v("p"),v("div",{staticClass:"table-of-contents"},[v("ul",[v("li",[v("a",{attrs:{href:"#特点"}},[t._v("特点")])]),v("li",[v("a",{attrs:{href:"#报文格式"}},[t._v("报文格式")])]),v("li",[v("a",{attrs:{href:"#有限状态机及状态变迁"}},[t._v("有限状态机及状态变迁")])]),v("li",[v("a",{attrs:{href:"#三次握手"}},[t._v("三次握手")]),v("ul",[v("li",[v("a",{attrs:{href:"#为什么需要第三次握手"}},[t._v("为什么需要第三次握手?")])]),v("li",[v("a",{attrs:{href:"#syn-flood-攻击"}},[t._v("SYN Flood 攻击")])])])]),v("li",[v("a",{attrs:{href:"#四次挥手"}},[t._v("四次挥手")]),v("ul",[v("li",[v("a",{attrs:{href:"#为什么需要四次挥手"}},[t._v("为什么需要四次挥手?")])]),v("li",[v("a",{attrs:{href:"#fin-wait-2-状态一直未接受到-fin-怎么办"}},[t._v("FINWAIT2 状态一直未接受到 FIN 怎么办?")])]),v("li",[v("a",{attrs:{href:"#为什么存在-time-wait-状态"}},[t._v("为什么存在 TIME_WAIT 状态?")])])])]),v("li",[v("a",{attrs:{href:"#可靠传输"}},[t._v("可靠传输")]),v("ul",[v("li",[v("a",{attrs:{href:"#自动重传请求协议-arq"}},[t._v("自动重传请求协议 ARQ")])])])]),v("li",[v("a",{attrs:{href:"#拥塞控制"}},[t._v("拥塞控制")])]),v("li",[v("a",{attrs:{href:"#q-a"}},[t._v("Q&A")]),v("ul",[v("li",[v("a",{attrs:{href:"#为什么多个tcp可以连接同一端口-比如http的80端口"}},[t._v("为什么多个TCP可以连接同一端口，比如HTTP的80端口?")])]),v("li",[v("a",{attrs:{href:"#rst-是什么-为什么会出现"}},[t._v("RST 是什么，为什么会出现")])])])]),v("li",[v("a",{attrs:{href:"#exercises"}},[t._v("Exercises")])])])]),v("p"),t._v(" "),v("h2",{attrs:{id:"特点"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#特点"}},[t._v("#")]),t._v(" 特点")]),t._v(" "),v("p",[v("strong",[t._v("面向连接")]),t._v("：使用 TCP 传输数据前，需先建立连接，传输完成后需释放连接。")]),t._v(" "),v("p",[v("strong",[t._v("全双工通信")]),t._v("：建立 TCP 连接后，双方都可以发送数据")]),t._v(" "),v("p",[v("strong",[t._v("可靠通信")]),t._v("：TCP协议保证数据不丢失，无差错，不重复且按序到达")]),t._v(" "),v("p",[v("strong",[t._v("面向字节流")]),t._v("：数据以流的形式传输")]),t._v(" "),v("div",{staticClass:"custom-block tip"},[v("p",{staticClass:"custom-block-title"},[t._v("TIP")]),t._v(" "),v("p",[t._v("TCP 会将数据报文分为数据段(data segment)传输，但由于其可靠性，上层可将其视为字节流传输")])]),t._v(" "),v("h2",{attrs:{id:"报文格式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#报文格式"}},[t._v("#")]),t._v(" 报文格式")]),t._v(" "),v("p",[v("img",{attrs:{src:a(371),alt:"TCP Header - 20 byte"}})]),t._v(" "),v("p",[t._v("报文首部最小长度为20字节")]),t._v(" "),v("p",[v("strong",[t._v("源端口，目的端口")]),t._v("：\n表明发送端所使用的端口号和要连接的目标主机的端口号，不包含IP地址。")]),t._v(" "),v("p",[v("strong",[t._v("序号（seq）")]),t._v("：\n表明发送的数据包的顺序，一般为上次发送包中的顺序号+1。\n若该数据包是整个TCP连接中的第一个包（SYN包），则该值是随机生成的。")]),t._v(" "),v("p",[v("strong",[t._v("确认号（ack）")]),t._v("：\n表明本端TCP已经接收到的数据，其值表示期待对端发送的下一个字节的序号。\n实际上告诉对方，在这个序号减1以前的字节已正确接收。\n若该数据包是整个TCP连接中的第一个包（SYN包），则确认号一般为0。")]),t._v(" "),v("p",[v("strong",[t._v("数据偏移")]),t._v("：\n表示以32位（4字节）为单位的TCP分组头的总长度（首部长度），用于确定用户数据区的起始位置。\n在没有可变内容的情况下，TCP头部的大小为20字节，对应该值为5。")]),t._v(" "),v("p",[v("strong",[t._v("标志位")]),t._v("：")]),t._v(" "),v("ul",[v("li",[t._v("紧急标志位（URG）：开启时表明此数据包处于紧急状态应该优先处理")]),t._v(" "),v("li",[t._v("确认标志位（ACK）：开启时表明确认号有效，否则忽略确认号")]),t._v(" "),v("li",[t._v("推送标志位（PSH）：开启时表明应该尽快交付给应用进程，而不必等到缓存区填满才推送，比如 telnet 的场景")]),t._v(" "),v("li",[t._v("复位标志位（RST）：开启时表明TCP连接出现连接出现错误，数据包非法拒绝连接")]),t._v(" "),v("li",[t._v("同步标志位（SYN）：开启时表明连接建立的标志")]),t._v(" "),v("li",[t._v("终止标志位（FIN）：开启时表明释放一个连接")])]),t._v(" "),v("p",[v("strong",[t._v("窗口大小")]),t._v("：\n表明期望接受到的数据包字节数，用于拥塞控制。")]),t._v(" "),v("p",[v("strong",[t._v("校验和")]),t._v("：\n实现对TCP报文头以及数据区进行校验。")]),t._v(" "),v("p",[v("strong",[t._v("紧急指针")]),t._v("：\n在紧急状态下（URG打开），指出窗口中紧急数据的位置（末端）。")]),t._v(" "),v("p",[v("strong",[t._v("选项（可变）")]),t._v("：\n用于支持一些特殊的变量，比如最大分组长度(MSS)，然后将其填充为32 bit的整数倍。")]),t._v(" "),v("h2",{attrs:{id:"有限状态机及状态变迁"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#有限状态机及状态变迁"}},[t._v("#")]),t._v(" 有限状态机及状态变迁")]),t._v(" "),v("p",[v("img",{attrs:{src:a(372),alt:"TCP State Machine"}})]),t._v(" "),v("p",[v("img",{attrs:{src:a(373),alt:"TCP State Transition"}})]),t._v(" "),v("h2",{attrs:{id:"三次握手"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#三次握手"}},[t._v("#")]),t._v(" 三次握手")]),t._v(" "),v("p",[v("img",{attrs:{src:a(374),alt:"TCP Shake hands"}})]),t._v(" "),v("p",[v("strong",[t._v("第一次握手")]),t._v("：\n客户端向服务器发送请求连接报文，SYN=1，seq=x(随机值)，客户端进入 SYN_SEND 状态，同时打开定时器")]),t._v(" "),v("p",[v("strong",[t._v("第二次握手")]),t._v("：\n服务器向客户端回信，SYN=1，ACK=1，seq=y(随机值)，ack=x+1，服务器端进入 SYN-RCVD 状态")]),t._v(" "),v("p",[v("strong",[t._v("第三次握手")]),t._v("：\n客户端向服务器回信，SYN=0，ACK=1，seq=x+1，ack=y+1，此次握手可以携带数据")]),t._v(" "),v("h3",{attrs:{id:"为什么需要第三次握手"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#为什么需要第三次握手"}},[t._v("#")]),t._v(" 为什么需要第三次握手?")]),t._v(" "),v("p",[t._v("这主要是为了防止已失效的连接请求报文段突然又传送到了B(服务器端)，因而产生错误。所谓“已失效的连接请求报文段”是这样产生的：")]),t._v(" "),v("p",[v("strong",[t._v("正常情况")])]),t._v(" "),v("p",[t._v("A发出连接请求，但因连接请求报文丢失而未收到确认，于是A再重传一次连接请求。后来收到了确认，建立了连接。数据传输完毕后，就释放了连接。A共发送了两个连接请求报文段，其中第一个丢失，第二个到达了B，没有“已丢失的连接请求报文段”。")]),t._v(" "),v("p",[v("strong",[t._v("异常情况")])]),t._v(" "),v("p",[t._v("A发出的第一个连接请求报文段并没有丢失，而是在某些网络节点长时间滞留了，以致延误到连接释放以后的某个时间才能到达B。")]),t._v(" "),v("p",[t._v("本来这是一个早已失效的报文段。但B收到此失效的连接请求报文段后，就误认为A又发出了一次新的连接请求。于是又向A发出确认报文段，同意建立连接。")]),t._v(" "),v("p",[t._v("假定不采用三次握手，那么只要B发出确认，新的连接就建立了。由于现在A并没有发出建立连接的请求，因此不会理睬B的确认，也不会向B发送数据。但B却以为新的连接已经建立了，并一直等待A发来数据，B的许多资源就这样浪费了。")]),t._v(" "),v("p",[t._v("采用三次握手的方法可以防止上述异常现象的发生。")]),t._v(" "),v("div",{staticClass:"custom-block warning"},[v("p",{staticClass:"custom-block-title"},[t._v("如果在规定时间内未收到回信")]),t._v(" "),v("p",[t._v("会重新发送SYN报文段。如果在几次重发后仍然没有得到服务器的SYN+ACK响应就会放弃，端口切换CLOSE状态，并报告上层。")])]),t._v(" "),v("h3",{attrs:{id:"syn-flood-攻击"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#syn-flood-攻击"}},[t._v("#")]),t._v(" SYN Flood 攻击")]),t._v(" "),v("p",[t._v("syn flood 是一种经典的 ddos攻击手段，这里面用到了TCP 三次握手存在的漏洞。\n在上面的图中，可以看到当服务端接收到 SYN 后进入 SYN-RECV 状态，此时的连接称为"),v("strong",[t._v("半连接")]),t._v("，同时会被服务端写入一个"),v("strong",[t._v("半连接队列")]),t._v("。")]),t._v(" "),v("p",[t._v("如果攻击者在短时间内不断的向服务端发送大量的 SYN 包而不响应，那么服务器的 半连接队列很快会被写满，从而导致无法工作。实现 syn flood 的手段，可以通过伪造源 IP 的方式，这样服务器的响应就永远到达不了客户端 (握手无法完成)，或通过设定客户端防火墙规则达到同样的目的。")]),t._v(" "),v("p",[t._v("对 syn flood 实现拦截是比较困难的，可以通过启用 syn_cookies 的方式实现缓解，但最好的办法是通过专业的防火墙来解决。")]),t._v(" "),v("h2",{attrs:{id:"四次挥手"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#四次挥手"}},[t._v("#")]),t._v(" 四次挥手")]),t._v(" "),v("p",[v("img",{attrs:{src:a(375),alt:"TCP wave"}})]),t._v(" "),v("h3",{attrs:{id:"为什么需要四次挥手"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#为什么需要四次挥手"}},[t._v("#")]),t._v(" 为什么需要四次挥手?")]),t._v(" "),v("p",[t._v("当一方发送了FIN，则表示在这一方不再会有数据的发送，进入半关闭状态，但是仍需要接受对方发送的消息。")]),t._v(" "),v("p",[t._v("其中当被动关闭方受到对方的FIN时，此时往往可能还有数据需要发送过去，因此无法立即发送FIN(也就是无法将FIN与ACK合并发送)，")]),t._v(" "),v("p",[t._v("而是在等待自己的数据发送完毕后再单独发送FIN，因此整个过程需要四次交互。")]),t._v(" "),v("h3",{attrs:{id:"fin-wait-2-状态一直未接受到-fin-怎么办"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#fin-wait-2-状态一直未接受到-fin-怎么办"}},[t._v("#")]),t._v(" FIN_WAIT_2 状态一直未接受到 FIN 怎么办?")]),t._v(" "),v("p",[t._v("1。为实现全双工，TCP协议规定需要一直等待FIN才会进入"),v("code",[t._v("TIME_WAIT")]),t._v("，即使网线被剪短...\n2。从Telnet，FTP，到Apache，Nginx，几乎所有的TCP服务的实现均遵循了收到客户端的FIN之后立即发送FIN这么一个不成文的事实，也就是说，对于主动关闭的一方，当它发送完FIN进入"),v("code",[t._v("FIN_WAIT_2")]),t._v("状态后，可以在预期的时间内收到对端的FIN从而进入TIMEWAIT状态\n3。Linux 2.2 以上可以根据"),v("code",[t._v("tcp_fin_timeout")]),t._v("配置定时器时长，默认 60s，超时后并不会进入TIMEWAIT状态，也不会发送reset。而 Windows 下表现一致，但是会发送reset")]),t._v(" "),v("h3",{attrs:{id:"为什么存在-time-wait-状态"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#为什么存在-time-wait-状态"}},[t._v("#")]),t._v(" 为什么存在 TIME_WAIT 状态?")]),t._v(" "),v("p",[t._v("当客户端收到了对方的FIN时，会进入TIME_WAIT状态，需要等待 2MSL 以直到确认不会再有重传的数据包之后再进入CLOSED状态")]),t._v(" "),v("p",[t._v("这么做的原因主要是为了可靠的关闭连接。为了防止网络不稳定情况，比如: 发送给对方的ACK可能会无法及时收到，此时对方可能重传FIN过来，如果提前进入CLOSE则会返回RST而不是ACK，就会影响关闭流程。")]),t._v(" "),v("p",[t._v("如果频繁的主动关闭连接，可能会产生大量"),v("code",[t._v("TIME_WAIT")]),t._v("，由于"),v("code",[t._v("TIME_WAIT")]),t._v("的连接占用了一个句柄及少量内存(4K)，那么就有可能会影响其他连接的建立，")]),t._v(" "),v("div",{staticClass:"custom-block tip"},[v("p",{staticClass:"custom-block-title"},[t._v("TIP")]),t._v(" "),v("p",[t._v("MSL叫Max Segment Lifetime，也就是关于一个数据包在网络中传输的最大生命周期的预设。关于其时长，RFC 中有 "),v("code",[t._v("Arbitrarily defined to be 2 minutes.")])])]),t._v(" "),v("h2",{attrs:{id:"可靠传输"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#可靠传输"}},[t._v("#")]),t._v(" 可靠传输")]),t._v(" "),v("p",[t._v("1。无差错\n2。发送&接受效率匹配")]),t._v(" "),v("h3",{attrs:{id:"自动重传请求协议-arq"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#自动重传请求协议-arq"}},[t._v("#")]),t._v(" 自动重传请求协议 ARQ")]),t._v(" "),v("p",[v("strong",[t._v("定义")]),t._v("\n传输出现差错时，接收方自动请求发送方重传出错数据")]),t._v(" "),v("p",[v("strong",[t._v("作用")]),t._v("\n无差错传输")]),t._v(" "),v("p",[v("strong",[t._v("确认机制")]),t._v("\n1。发送方每发送一帧，都需要等待接收方应答信号\n2。接收方每接受一帧，都需要反馈一个应答信号\n3。若接收方不反馈应答信号，则发送方必需一直等待")]),t._v(" "),v("p",[v("strong",[t._v("超时重传")]),t._v("\n1。发送方发送帧后开启计时器\n2。超时后重发该数据帧，直到发送成功为止")]),t._v(" "),v("h4",{attrs:{id:"停等式-arq-stop-and-wait"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#停等式-arq-stop-and-wait"}},[t._v("#")]),t._v(" 停等式 ARQ (Stop and Wait)")]),t._v(" "),v("p",[t._v("发送窗口大小 = 1\n接受窗口大小 = 1")]),t._v(" "),v("h4",{attrs:{id:"后退n帧协议-连续arq协议"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#后退n帧协议-连续arq协议"}},[t._v("#")]),t._v(" 后退N帧协议 (连续ARQ协议)")]),t._v(" "),v("p",[t._v("发送窗口大小 > 1\n接受窗口大小 = 1")]),t._v(" "),v("h5",{attrs:{id:"累计确认"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#累计确认"}},[t._v("#")]),t._v(" 累计确认")]),t._v(" "),v("p",[t._v("收到多个数据分组后，只需对按序到达的最后一个分组确认")]),t._v(" "),v("p",[v("strong",[t._v("优点")]),t._v("\n实现简单")]),t._v(" "),v("p",[v("strong",[t._v("缺点")]),t._v("\n无法向发送方反馈所有正确接收到的分组信息")]),t._v(" "),v("h5",{attrs:{id:"后退n帧"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#后退n帧"}},[t._v("#")]),t._v(" 后退N帧")]),t._v(" "),v("h2",{attrs:{id:"拥塞控制"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#拥塞控制"}},[t._v("#")]),t._v(" 拥塞控制")]),t._v(" "),v("p",[t._v("慢启动，拥塞避免，快速重传，快速恢复")]),t._v(" "),v("h2",{attrs:{id:"q-a"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#q-a"}},[t._v("#")]),t._v(" Q&A")]),t._v(" "),v("h3",{attrs:{id:"为什么多个tcp可以连接同一端口-比如http的80端口"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#为什么多个tcp可以连接同一端口-比如http的80端口"}},[t._v("#")]),t._v(" 为什么多个TCP可以连接同一端口，比如HTTP的80端口?")]),t._v(" "),v("p",[t._v("TODO")]),t._v(" "),v("h3",{attrs:{id:"rst-是什么-为什么会出现"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#rst-是什么-为什么会出现"}},[t._v("#")]),t._v(" RST 是什么，为什么会出现")]),t._v(" "),v("p",[t._v("RST 是一个特殊的标记，用来表示当前应该立即终止连接。以下这些情况都会产生RST：")]),t._v(" "),v("ul",[v("li",[t._v("向一个未被监听的端口发送数据")]),t._v(" "),v("li",[t._v("对方已经调用 close 关闭连接")]),t._v(" "),v("li",[t._v("存在一些数据未处理(接收缓冲区)，请求关闭连接时，会发送RST强制关闭")]),t._v(" "),v("li",[t._v("某些请求发生了超时")])]),t._v(" "),v("p",[t._v("RST 机制有时候也会被利用，做一些"),v("a",{attrs:{href:"https://nmap.org/man/zh/man-port-scanning-techniques.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("端口扫描"),v("OutboundLink")],1)]),t._v(" "),v("h2",{attrs:{id:"exercises"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#exercises"}},[t._v("#")]),t._v(" Exercises")]),t._v(" "),v("p",[t._v("1。A,B两台机器都正常工作,B机器未监听任何端口。如果A机器向B机器80端口发送SYN包,会收到何种类型的回包?")]),t._v(" "),v("blockquote",[v("p",[t._v("RST包")])]),t._v(" "),v("p",[t._v("2。TCP建立连接的过程采用三次握手，已知第三次握手报文的发送序列号为1000，确认序列号为2000，请问第二次握手报文的发送序列号和确认序列号分别为?")]),t._v(" "),v("blockquote",[v("p",[t._v("1999,1000")])])])}),[],!1,null,null,null);_.default=s.exports}}]);