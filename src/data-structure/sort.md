---
title: 排序
date: 2019-10-24 19:30:32
categories:
  - Computer Science
  - Data Structure
  - Sort
tags: 
  - Data Structure
---

# Sort

# 插入排序

将第 i 个记录插入前面 i-1 个已排序记录

## 直接插入法

监视哨:

1. 备份待插入数据
2. 防止越界

## 折半插入法

改善比较效率, 但未改变元素插入效率

## 希尔排序

1. 选取记录距离为$d_i(i=1)$, 将待排序序列中将间隔为$d_1$的记录分成一组, 组内排序
2. i++, 将待排序序列中将间隔为$d_i$的记录分成一组. 组内排序
3. 重复步骤 2, 直到$d_i=1$

## 比较

| 算法     | 改进思路                   | 时间复杂度                       | 最好情况   | 最坏情况 | 空间复杂度 |
| -------- | -------------------------- | -------------------------------- | ---------- | -------- | ---------- |
| 直接插入 | 最好情况: n 较小, 基本有序 | $O(n^2)$                         | $O(n)$     | $O(n^2)$ | $O(1)$     |
| 折半插入 | 利用折半实现确定插入       | $O(n^2)$, 比较时间: $O(nlog_2n)$ | $O(nlogn)$ | $O(n^2)$ | $O(1)$     |
| 希尔排序 | 利用直接插入的最好情况     | $O(n^{1.5})$                     |            |          | $O(1)$     |

# 交换排序

## 冒泡排序

时间复杂度: $O(n^2)$

## 快速排序

时间复杂度: $O(nlog_2n)$

1. 选取记录$K_1$, 将比$K_1$大的移动到$K_1$前, 比$K_1$小的移动到$K_1$后, 将其分割为 2 个表
2. 对子表进行快速排序, 直到每个子表长度不超过 1

```C
void QKSort(RecordType r[], int low, int height) {
  if (low < high) {
    pos = QKPass(r, low, high);
    QKSort(r, low, pos-1);
    QKSort(r, pos+1, high);
  }
}

int QKPass(RecordType r[], int low, int height) {
  RecordType x = row[low];
  while (low < high) {
    // high 右 -> 左
    while (low < high && r[high].key >= x.key) {
      high--;
    }
    if (low < high) {
      r[low] = r[high];
      low++;
    }
    // low 左 -> 右
    while (low < high && r[low].key < x.key) {
      low++;
    }
    if (low < high) {
      r[high] = r[low];
      high--;
    }
  }
  r[low] = x;
  return low
}
```

# 选择排序

每一趟在 $n-i+1(i=1,2...n-1)$ 个记录中选取最小的记录作为第 $i$ 个记录

## 简单选择

时间复杂度: $O(n^2)$

## 树形选择(锦标赛排序)

思路: 利用上次比较结果

1. 将 n 个记录两两比较取较小值, 重复该步骤得到最小值, 同时构建出一个满二叉树(用$\infin$补全)
2. 将最小值用$\infin$代替, 并更新其至根节点的路径
3. 重复上述步骤, 得到排序后的序列

## 堆排序

TODO

# 归并排序

TODO

基于合并, 将两个或两个以上有序表合并成一个新的有序表

# 分配类排序

TODO

# 综合比较

| 排序方法 | 平均时间复杂度 | 最坏时间复杂度 | 辅助存储空间 |
| -------- | -------------- | -------------- | ------------ |
| 简单排序 | $O(n^2)$       | $O(n^2)$       | $O(1)$       |
| 快速排序 | $O(nlog_2n)$   | $O(n^2)$       | $O(log_2n)$  |
| 堆排序   | $O(nlog_2n)$   | $O(nlog_2n)$   | $O(1)$       |
| 归并排序 | $O(nlog_2n)$   | $O(nlog_2n)$   | $O(n)$       |
| 基数排序 | $O(d(n+rd))$   | $O(d(n+rd))$   | $O(rd)$      |

| 排序方法     | 稳定性 | 反例                    |
| ------------ | ------ | ----------------------- |
| 直接插入排序 | 是     |
| 冒泡排序     | 是     |
| 简单选择     | 否     | $(3,3,2)$               |
| 希尔排序     | 否     | $(2,4,1,2)d_1=2, d_2=1$ |
| 快速排序     | 否     | $(3,2,2)$               |
| 堆排序       | 否     | $(5,5,3)$               |
| 归并排序     | 是     |
| 基数排序     | 是     |
